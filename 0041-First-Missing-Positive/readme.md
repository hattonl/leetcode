### 题目

寻找数组中缺失的最小正整数，要求时间复杂度为O(n)，空间复杂度O(1)。

**Example 1:**

```
Input: [1,2,0]
Output: 3
```

**Example 2:**

```
Input: [3,4,-1,1]
Output: 2
```

**Example 3:**

```
Input: [7,8,9,11,12]
Output: 1
```

### 思路

如果不考虑时间复杂度的情况下，对于这道题能够想到的最简单的方法就是先将原数组按照大小进行排序，然后遍历查找即可得数组中缺失的最小的正整数。这样就需要寻找一个时间复杂度是O(n) 的排序算法，然而当前的线性时间排序算法（计数排序、基数排序、桶排序）的性能都与原数据的特征有一定的关系，所以在本题目中不太适用。

但是在这个题目的要求中，似乎并不需要对所有的数据进行排序。排查题目答案的可能范围可以得出如下的结论。

> 本题目中，如果给定一个数组nums包含了n个元素，那么数组中缺失的最小正整数一定属于闭区间[1, n+1]。上述结论可以使用反证法轻松地证明出来。

这样的话，我们就可以在这个基础上使用借鉴桶排序的思想。假定数组B[]，大小为n，初始全部元素设置为0。遍历给定数组nums[]，当nums[i] 属于闭区间[1, n]时，令B[nums[i] -1] = 1。这样遍历完数组nums[]之后，再遍历数组B[] ,下标从小到大开始遍历，第一个不为1的元素时返回其下标再加1既为所求。若数组B[] 中所有的元素都为1，则返回n + 1。

由于申请了数组B[]，上述方法的空间复杂度为O(n)，在这个题目中是不符合要求的。不过上述方法在阐述思路上就比较简单，在实际解这道题目时，可以直接利用原数组nums[] 来当作“桶”存储数据，核心思想与上述相同。具体操作如下。

依照下标自小向大的顺序遍历给定数组nums[]，如果nums[i] 属于闭区间 [1, n]。则将其与nums[nums[i] - 1] 上的元素交换位置。否则不进行操作。这一步是为了保证将使属于闭区间 [1, n]的元素 a，都在nums[a - 1]位置上。然后在进行第二遍遍历时，找到第一个nums[a - 1] != a 的位置即可，返回 a 即是答案。如果数组中所有的元素都满足nums[ i - 1] == i，则返回 n+1。

代码实现如下：

```c
void swap(int *a, int *b)
{
    int temp;
    temp = *a;
    *a   = *b;
    *b   = temp;
}
int firstMissingPositive(int* nums, int numsSize) {
    int ret = 0;
    for (int i = 0; i < numsSize; i ++)
    {
        while (nums[i] > 0         \ 
            && nums[i] <= numsSize \
            && nums[i] != i+1      \
            && nums[nums[i]-1] != nums[i] )
        {
            swap(&nums[i], &nums[nums[i]-1]);
        }
    }
    for (ret = 0; ret < numsSize; ret ++)
        if (nums[ret] != ret+1) break;
    
    return ret + 1;
}
```